/*
 * This Java source file was generated by the Gradle 'init' task.
 */
/**
 * This is a command line interface wrapper for the ImageJ plugin "ImageStabilizer"
 * Usage:
 * execute the jar from command line as usual, with flags that each receive arguments
 * "java -jar [path to this .jar] -i [path to tiff files]
 *                                -o [path to destination folder]
 *                                -s []
 *                                -t []
 *                                -p []
 *                                -update []
 *                                -iter []
 *                                -tol []
 */

import ij.ImagePlus;
import ij.ImageStack;
import ij.plugin.FolderOpener;
import ij.io.Opener;
import ij.process.ImageProcessor;
import org.apache.commons.cli.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ImageStabilizerCLI {

    private static final ExecutorService ijExecutor = Executors.newFixedThreadPool(5);;

    public static void main(String[] args) throws Exception {

        String inputFilePath = null;
        String outputFilePath = null;
        String substring = null;
        String transformationType = null;
        Integer pyramids = null;
        Float coeff = null;
        Integer iterations = null;
        Double tolerance = null;
        boolean logEnabled = false;
        String logPath = null;
        Integer slice = null;

        Image_Stabilizer IS = null;
        Image_Stabilizer_Log_Applier ISLA = null;

        Options options = new Options();

        Option input = new Option("i", "input", true, "input file path");
        input.setRequired(true);
        options.addOption(input);

        Option output = new Option("o", "output", true, "output file path");
        output.setRequired(true);
        options.addOption(output);

        Option ss = new Option("s", "substring", true, "substring with which to filter the input files");
        ss.setRequired(false);
        options.addOption(ss);

        Option transformation = new Option("t", "transformation", true, "transformation type: Translation or Affine");
        transformation.setRequired(true);
        options.addOption(transformation);

        Option maxPyramids = new Option("p", "maxPyramids", true, "Maximum Pyramid Levels: 0, 1, 2, 3, 4");
        maxPyramids.setRequired(false);
        options.addOption(maxPyramids);

        Option updateCoeff = new Option("update", "updateCoeff", true, "Template Update Coefficient (default 0.9): 0 - 1");
        updateCoeff.setRequired(false);
        options.addOption(updateCoeff);

        Option maxIterations = new Option("iter", "maxIterations", true, "Maximum num iterations (default 200)");
        maxIterations.setRequired(false);
        options.addOption(maxIterations);

        Option maxTolerance = new Option("tol", "maxTolerance", true, "Error Tolerance (default 1e-7");
        maxTolerance.setRequired(false);
        options.addOption(maxTolerance);

        Option logger = new Option("log", "logEnabled", false, "Flag to turn on coordinate logging");
        logger.setRequired(false);
        options.addOption(logger);

        Option zSlice = new Option("z", "zSlice", true, "Flag to turn on coordinate logging");
        zSlice.setRequired(false);
        options.addOption(zSlice);

        Option logApply = new Option("applier", "logApplier", true, "Flag to signify that a log file will be applied");
        logApply.setRequired(false);
        options.addOption(logApply);

        CommandLineParser parser = new DefaultParser();
        HelpFormatter formatter = new HelpFormatter();
        CommandLine cmd;

        // parse the cmd line and assign values
        try {
            cmd = parser.parse(options, args);
            inputFilePath = cmd.getOptionValue("input");
            outputFilePath = cmd.getOptionValue("output");
            transformationType = cmd.getOptionValue("transformation");

            if(cmd.hasOption("maxPyramids")){
                pyramids = Integer.parseInt(cmd.getOptionValue("maxPyramids"));
            }
            if(cmd.hasOption("substring")){
                substring = cmd.getOptionValue("substring");
            }
            if(cmd.hasOption("updateCoeff")){
                coeff = Float.parseFloat(cmd.getOptionValue("updateCoeff"));
            }
            if(cmd.hasOption("maxIterations")){
                iterations = Integer.parseInt(cmd.getOptionValue("iterations"));
            }
            if(cmd.hasOption("maxTolerance")){
                tolerance = Double.parseDouble(cmd.getOptionValue("maxTolerance"));
            }
            if (cmd.hasOption("logEnabled")){
                logEnabled = true;
            }
            if (cmd.hasOption("logApplier")){
                logPath = cmd.getOptionValue("logApplier");
            }
            if (cmd.hasOption("zSlice")) {
                slice = Integer.parseInt(cmd.getOptionValue("zSlice"));
            }
            System.out.println("cmd line args retrieved");

        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp("utility-name", options);

            System.exit(1);
        }

        // filter the list of images by substring and create an ImagePlus from them
        try {
            System.out.println("parsing");
            List<String> filteredTiffs = parseTiffs(inputFilePath, substring, slice, ".tif");

            System.out.println("casting tiffs to string array");
            String[] s = Arrays.copyOf(filteredTiffs.toArray(), filteredTiffs.toArray().length, String[].class);

            System.out.println("sorting tiffs");
            FolderOpener fo = new FolderOpener();
            String[] sortedTiffs = fo.sortFileList(s);

            List<String> slist = Arrays.asList(sortedTiffs);
            slist.forEach(System.out::println);

            System.out.println("Creating ImagePlus and Stabilizer Constructor");
            ImageStack stack = toStack(sortedTiffs);
            ImagePlus iplus = new ImagePlus(String.format("img_%s", substring), stack);

            if (coeff != null && iterations != null && tolerance != null && logPath == null) {
                IS = new Image_Stabilizer(iplus, transformationType, outputFilePath, logEnabled, pyramids, coeff, iterations, tolerance);
            } else if (logPath == null) {
                IS = new Image_Stabilizer(iplus, transformationType, outputFilePath, logEnabled);
            } else {
                ISLA = new Image_Stabilizer_Log_Applier(iplus, transformationType, outputFilePath, logPath);
            }
            System.out.println("Stabilizer initialized");

        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            System.exit(1);
        }

        // run in another thread
        System.out.println("Launching executor");
        if (logPath != null) {
            ISLA.run();
        } else {
//            ijExecutor.execute(IS);
            IS.run();
        }
    }

    /**
     * retrieve an list of files within the directory.
     * files are filtered by extension and substring
     * @param inputFilePath_ : folder containing tiff files
     * @param substring_ : filter by substring, can be null
     * @param extension_ : filter by extension
     * @return : unsorted list of string paths
     */
    private static List<String> parseTiffs(String inputFilePath_, String substring_, Integer slice_, String extension_) {
        final String sstring = substring_;
        final String extension = extension_;
        final Integer slice = slice_;

        try (Stream<Path> walk = Files.walk(Paths.get(inputFilePath_))) {

            Stream<String> build = walk.filter(Files::isRegularFile)
                    .map(x -> x.toString());

            if(extension != null) {
                System.out.println("extension specified");
                build = build.filter(f -> f.endsWith(extension));
            }
            if(sstring != null) {
                System.out.println("substring specified");
                build = build.filter(f -> f.contains(sstring));
            }
            if(slice != null) {
                System.out.println("z slice specified");
                build = build.filter(f -> f.contains(String.format("z%03d", slice)));
            }
            return build.collect(Collectors.toList());
//
//            if(sstring == null) {
//                build = build.filter(f -> f.endsWith(extension));
////                List<String> images = walk.filter(Files::isRegularFile)
////                        .map(x -> x.toString())
////                        .filter(f -> f.endsWith(extension));
////                        .collect(Collectors.toList());
//                System.out.println("filter");
////                return images;
//            } else {
//                List<String> images = walk.filter(Files::isRegularFile)
//                        .map(x -> x.toString())
//                        .filter(f -> f.endsWith(extension))
//                        .filter(f -> f.contains(sstring))
//                        .collect(Collectors.toList());
//                System.out.println("substring filter");
//                return images;
//            }
        } catch (IOException e) {
            System.out.println(e.toString());
            return null;
        } catch (Exception ex) {
            System.out.println(ex.toString());
            return null;
        }
    }

    /**
     * create a multipage tiff stack from supplied array of .tiff paths
     * @param images : String array of paths
     * @return : ImageStack object
     */
    private static ImageStack toStack(String[] images) {

        try {
            ImagePlus imout;
            ImageStack imstk = null;
            Opener op = new Opener();
            for (String image : images) {

                if (imstk == null) {
                    imout = op.openImage(image);
                    imstk = imout.getStack();
                } else {
                    imout = op.openImage(image);
                    ImageProcessor ip = imout.getProcessor();
                    imstk.addSlice(ip);
                }
            }
            return imstk;
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }
}
